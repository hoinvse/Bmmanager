import tkinter as tk
from tkinter import ttk, messagebox, filedialog, simpledialog
import csv
import json
import os
import shutil
from datetime import datetime

class BMManager:
    def __init__(self, root):
        self.root = root
        self.root.title("BM Manager - Qu·∫£n l√Ω Business Manager Facebook")
        self.root.geometry("1200x800")
        
        # Maximize window
        try:
            self.root.state('zoomed')  # Windows
        except Exception:
            try:
                self.root.attributes('-zoomed', True)  # Linux
            except Exception:
                pass
        
        # Modern color scheme
        self.colors = {
            'primary': '#2563eb',      # Blue-600
            'primary_light': '#3b82f6', # Blue-500
            'primary_dark': '#1d4ed8',  # Blue-700
            'secondary': '#10b981',     # Emerald-500
            'accent': '#f59e0b',        # Amber-500
            'danger': '#ef4444',        # Red-500
            'bg_primary': '#ffffff',    # White
            'bg_secondary': '#f8fafc',  # Slate-50
            'bg_card': '#ffffff',       # White
            'text_primary': '#1f2937',  # Gray-800
            'text_secondary': '#6b7280', # Gray-500
            'border': '#e5e7eb',        # Gray-200
            'hover': '#f3f4f6',         # Gray-100
            'success': '#22c55e',       # Green-500
        }
        
        self.root.configure(bg=self.colors['bg_secondary'])
        
        # Create modern style
        self.create_modern_style()
        
        # Initialize data
        self.bm_data = []
        self.current_file = None
        self.data_dir = os.path.join(os.path.dirname(__file__), 'bm_data')
        self.current_folder = 'default'
        self.db_path = os.path.join(self.data_dir, self.current_folder, 'bm_data.json')
        
        # Create data directory
        if not os.path.exists(self.data_dir):
            os.makedirs(self.data_dir)
        if not os.path.exists(os.path.join(self.data_dir, 'default')):
            os.makedirs(os.path.join(self.data_dir, 'default'))
        
        # Create widgets
        self.create_widgets()
        self.load_json_db()
        
    def create_modern_style(self):
        """T·∫°o style hi·ªán ƒë·∫°i"""
        self.style = ttk.Style()
        
        # Configure modern theme
        self.style.theme_use('clam')
        
        # Configure modern styles
        self.style.configure('Modern.TFrame', 
                           background=self.colors['bg_card'],
                           relief='flat',
                           borderwidth=1)
        
        self.style.configure('Card.TFrame',
                           background=self.colors['bg_card'],
                           relief='solid',
                           borderwidth=1,
                           padding=20)
        
        self.style.configure('Modern.TLabel',
                           background=self.colors['bg_card'],
                           foreground=self.colors['text_primary'],
                           font=('Segoe UI', 10))
        
        self.style.configure('Title.TLabel',
                           background=self.colors['bg_secondary'],
                           foreground=self.colors['primary'],
                           font=('Segoe UI', 18, 'bold'))
        
        self.style.configure('Subtitle.TLabel',
                           background=self.colors['bg_card'],
                           foreground=self.colors['text_secondary'],
                           font=('Segoe UI', 11, 'bold'))
        
        # Modern buttons
        self.style.configure('Primary.TButton',
                           background=self.colors['primary'],
                           foreground='white',
                           font=('Segoe UI', 9, 'bold'),
                           padding=(15, 8),
                           relief='flat',
                           borderwidth=0)
        
        self.style.map('Primary.TButton',
                      background=[('active', self.colors['primary_light']),
                                ('pressed', self.colors['primary_dark'])])
        
        self.style.configure('Success.TButton',
                           background=self.colors['success'],
                           foreground='white',
                           font=('Segoe UI', 9, 'bold'),
                           padding=(12, 6),
                           relief='flat')
        
        self.style.configure('Danger.TButton',
                           background=self.colors['danger'],
                           foreground='white',
                           font=('Segoe UI', 9, 'bold'),
                           padding=(12, 6),
                           relief='flat')
        
        self.style.configure('Accent.TButton',
                           background=self.colors['accent'],
                           foreground='white',
                           font=('Segoe UI', 9, 'bold'),
                           padding=(12, 6),
                           relief='flat')
        
        # Modern notebook
        self.style.configure('Modern.TNotebook',
                           background=self.colors['bg_secondary'],
                           tabposition='n')
        
        self.style.configure('Modern.TNotebook.Tab',
                           background=self.colors['bg_card'],
                           foreground=self.colors['text_primary'],
                           padding=(20, 12),
                           font=('Segoe UI', 11, 'bold'))
        
        self.style.map('Modern.TNotebook.Tab',
                      background=[('selected', self.colors['primary']),
                                ('active', self.colors['hover'])],
                      foreground=[('selected', 'white'),
                                ('active', self.colors['text_primary'])])
        # Hide notebook tabs (we'll switch via header buttons)
        try:
            self.style.layout('Modern.TNotebook.Tab', [])
        except Exception:
            pass
        
        # Modern treeview
        self.style.configure('Modern.Treeview',
                           background='white',
                           foreground=self.colors['text_primary'],
                           fieldbackground='white',
                           borderwidth=0,
                           relief='flat',
                           font=('Segoe UI', 11),
                           rowheight=38)
        
        self.style.configure('Modern.Treeview.Heading',
                           background=self.colors['primary'],
                           foreground='white',
                           font=('Segoe UI', 10, 'bold'),
                           padding=(6, 8))
        
        self.style.map('Modern.Treeview',
                      background=[('selected', self.colors['primary_light'])],
                      foreground=[('selected', 'white')])
        
        # Modern entry
        self.style.configure('Modern.TEntry',
                           fieldbackground='white',
                           borderwidth=2,
                           relief='solid',
                           padding=(10, 8),
                           font=('Segoe UI', 10))
        
        # Modern combobox
        self.style.configure('Modern.TCombobox',
                           fieldbackground='white',
                           borderwidth=2,
                           relief='solid',
                           padding=(10, 8),
                           font=('Segoe UI', 10))
        
        # Modern radiobutton
        self.style.configure('Modern.TRadiobutton',
                           background=self.colors['bg_card'],
                           foreground=self.colors['text_primary'],
                           font=('Segoe UI', 10),
                           focuscolor='none')
        
        self.style.map('Modern.TRadiobutton',
                      background=[('active', self.colors['hover'])],
                      foreground=[('active', self.colors['text_primary'])])
        
    def create_widgets(self):
        # Main container
        main_container = ttk.Frame(self.root, style='Modern.TFrame')
        main_container.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
        
        # Header
        header_frame = ttk.Frame(main_container, style='Card.TFrame')
        header_frame.pack(fill=tk.X, pady=(0, 20))
        
        # Title with modern styling
        title_label = ttk.Label(header_frame, 
                               text="üöÄ BM Manager Pro",
                               style='Title.TLabel')
        title_label.pack(pady=(0, 5))
        
        subtitle_label = ttk.Label(header_frame,
                                 text="Qu·∫£n l√Ω Business Manager Facebook m·ªôt c√°ch chuy√™n nghi·ªáp",
                                 style='Subtitle.TLabel')
        subtitle_label.pack()
        
        # Tab switch buttons in header (top-left)
        tabs_switch = ttk.Frame(header_frame, style='Modern.TFrame')
        tabs_switch.pack(anchor=tk.W, pady=(10, 0))
        ttk.Button(tabs_switch, text="üìä Qu·∫£n l√Ω", style='Primary.TButton',
                  command=lambda: self.notebook.select(self.manage_tab)).pack(side=tk.LEFT, padx=(0, 10))
        ttk.Button(tabs_switch, text="üîç L·ªçc Link", style='Accent.TButton',
                  command=lambda: self.notebook.select(self.filter_tab)).pack(side=tk.LEFT)
        
        # Modern notebook with custom style
        self.notebook = ttk.Notebook(main_container, style='Modern.TNotebook')
        self.notebook.pack(fill=tk.BOTH, expand=True)
        
        # Create tabs
        self.create_manage_tab()
        self.create_filter_tab()
        
    def create_manage_tab(self):
        # Management tab
        manage_frame = ttk.Frame(self.notebook, style='Modern.TFrame')
        self.manage_tab = manage_frame
        self.notebook.add(manage_frame, text="üìä Qu·∫£n l√Ω")
        
        
        # Scrollable container (full-width)
        canvas = tk.Canvas(manage_frame, bg=self.colors['bg_secondary'], highlightthickness=0)
        scrollbar = ttk.Scrollbar(manage_frame, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas, style='Modern.TFrame')
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        window_id = canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        # Ensure inner frame stretches to canvas width
        def _resize_inner(event):
            try:
                canvas.itemconfig(window_id, width=event.width)
            except Exception:
                pass
        canvas.bind('<Configure>', _resize_inner)
        canvas.configure(yscrollcommand=scrollbar.set)
        
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        # Folder management card
        folder_card = ttk.Frame(scrollable_frame, style='Card.TFrame')
        folder_card.pack(fill=tk.X, pady=(0, 20))
        
        folder_title = ttk.Label(folder_card, text="üìÅ Qu·∫£n l√Ω th∆∞ m·ª•c", style='Subtitle.TLabel')
        folder_title.pack(anchor=tk.W, pady=(0, 15))
        
        folder_controls = ttk.Frame(folder_card, style='Modern.TFrame')
        folder_controls.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(folder_controls, text="Th∆∞ m·ª•c hi·ªán t·∫°i:", style='Modern.TLabel').pack(side=tk.LEFT, padx=(0, 10))
        
        self.folder_var = tk.StringVar(value=self.current_folder)
        self.folder_combo = ttk.Combobox(folder_controls, textvariable=self.folder_var, 
                                       width=20, state='readonly', style='Modern.TCombobox')
        self.folder_combo.pack(side=tk.LEFT, padx=(0, 15))
        self.folder_combo.bind('<<ComboboxSelected>>', self.on_folder_change)
        
        # Modern buttons with icons
        ttk.Button(folder_controls, text="‚ûï T·∫°o", style='Success.TButton',
                  command=self.create_folder).pack(side=tk.LEFT, padx=(0, 8))
        ttk.Button(folder_controls, text="üóëÔ∏è X√≥a", style='Danger.TButton',
                  command=self.delete_folder).pack(side=tk.LEFT, padx=(0, 8))
        ttk.Button(folder_controls, text="‚úèÔ∏è ƒê·ªïi t√™n", style='Accent.TButton',
                  command=self.rename_folder).pack(side=tk.LEFT, padx=(0, 8))
        ttk.Button(folder_controls, text="üì¶ Move", style='Primary.TButton',
                  command=self.move_selected).pack(side=tk.LEFT, padx=(0, 8))
        ttk.Button(folder_controls, text="üíæ T·∫£i DB", style='Success.TButton',
                  command=self.load_json_db).pack(side=tk.LEFT, padx=(0, 8))
        ttk.Button(folder_controls, text="üîÑ L√†m m·ªõi", style='Primary.TButton',
                  command=self.refresh_folders).pack(side=tk.LEFT)
        
        # Status label placed on the right within folder controls
        status_spacer = ttk.Frame(folder_controls, style='Modern.TFrame')
        status_spacer.pack(side=tk.RIGHT, padx=(0, 40))
        self.status_var = getattr(self, 'status_var', tk.StringVar(value="T·ªïng: 0 | ƒê√£ ch·ªçn: 0"))
        ttk.Label(status_spacer, textvariable=self.status_var,
                  style='Modern.TLabel', font=('Segoe UI', 10, 'bold')).pack(side=tk.RIGHT)
        
        # Folder info
        self.folder_info_var = tk.StringVar()
        info_label = ttk.Label(folder_card, textvariable=self.folder_info_var, style='Modern.TLabel')
        info_label.pack(anchor=tk.W, pady=(10, 0))
        
        # Data table card
        table_card = ttk.Frame(scrollable_frame, style='Card.TFrame')
        table_card.pack(fill=tk.BOTH, expand=True, pady=(0, 20))
        
        table_title = ttk.Label(table_card, text="üìã Danh s√°ch Business Manager", style='Subtitle.TLabel')
        table_title.pack(anchor=tk.W, pady=(0, 15))
        
        # Table container with border
        table_container = ttk.Frame(table_card)
        table_container.pack(fill=tk.BOTH, expand=True)
        
        # Create modern treeview
        self.columns = ('STT', 'Ch·ªçn', 'TypeBM', 'ID', 'BmID', 'Th∆∞ m·ª•c', 'Ghi ch√∫', 'Link1', 'Link2', 'Link3')
        self.tree = ttk.Treeview(table_container, columns=self.columns, show='headings', 
                               height=20, style='Modern.Treeview')
        # Faint Excel-like row stripes
        try:
            self.tree.tag_configure('row_even', background='#ffffff')
            self.tree.tag_configure('row_odd', background=self.colors.get('bg_secondary', '#f8fafc'))
        except Exception:
            pass
        
        # Configure columns
        column_configs = [
            ('STT', 60, 'STT'),
            ('Ch·ªçn', 80, 'Ch·ªçn'),
            ('TypeBM', 100, 'Type BM'),
            ('ID', 150, 'ID'),
            ('BmID', 150, 'BM ID'),
            ('Th∆∞ m·ª•c', 200, 'Th∆∞ m·ª•c'),
            ('Ghi ch√∫', 220, 'Ghi ch√∫'),
            ('Link1', 400, 'Link 1'),
            ('Link2', 400, 'Link 2'),
            ('Link3', 400, 'Link 3')
        ]
        
        for col_id, width, text in column_configs:
            # Heading alignment
            if col_id in ('STT', 'Ch·ªçn'):
                self.tree.heading(col_id, text=text, anchor=tk.CENTER, command=lambda c=col_id: self.sort_by_column(c))
            else:
                self.tree.heading(col_id, text=text, anchor=tk.W, command=lambda c=col_id: self.sort_by_column(c))

            # Cell alignment
            if col_id in ('Link1', 'Link2', 'Link3'):
                self.tree.column(col_id, width=width, minwidth=120, anchor=tk.W, stretch=True)
            elif col_id in ('STT', 'Ch·ªçn'):
                self.tree.column(col_id, width=width, minwidth=20, anchor=tk.CENTER, stretch=False)
            else:
                self.tree.column(col_id, width=width, minwidth=60, anchor=tk.W, stretch=False)
        
        # Modern scrollbars
        tree_v_scrollbar = ttk.Scrollbar(table_container, orient=tk.VERTICAL, command=self.tree.yview)
        tree_h_scrollbar = ttk.Scrollbar(table_container, orient=tk.HORIZONTAL, command=self.tree.xview)
        self.tree.configure(yscrollcommand=tree_v_scrollbar.set, xscrollcommand=tree_h_scrollbar.set)
        
        # Pack treeview and scrollbars
        self.tree.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        tree_v_scrollbar.grid(row=0, column=1, sticky=(tk.N, tk.S))
        tree_h_scrollbar.grid(row=1, column=0, sticky=(tk.W, tk.E))
        
        table_container.columnconfigure(0, weight=1)
        table_container.rowconfigure(0, weight=1)
        
        # Bind events
        self.tree.bind('<<TreeviewSelect>>', self.on_select)
        self.tree.bind('<Button-1>', self.on_tree_click)
        self.tree.bind('<Double-1>', self.on_cell_double_click)
        self.tree.bind('<Control-c>', self.copy_cell)
        self.tree.bind('<Control-C>', self.copy_cell)
        
        self.sort_directions = {}
        self.current_cell = (None, None)
        
        # Create context menu
        self.create_context_menu()
        
        # Action buttons moved into context menu; status moved into folder controls
        
        # Initialize data
        self.rowid_to_index = {}
        self.refresh_folders()
        
    def create_filter_tab(self):
        # Filter tab
        filter_frame = ttk.Frame(self.notebook, style='Modern.TFrame')
        self.filter_tab = filter_frame
        self.notebook.add(filter_frame, text="üîç L·ªçc Link")
        
        filter_container = ttk.Frame(filter_frame, style='Modern.TFrame')
        filter_container.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
        
        # Filter card
        filter_card = ttk.Frame(filter_container, style='Card.TFrame')
        filter_card.pack(fill=tk.X, pady=(0, 20))
        
        filter_title = ttk.Label(filter_card, text="üéØ L·ªçc theo BmID", style='Subtitle.TLabel')
        filter_title.pack(anchor=tk.W, pady=(0, 15))
        
        ttk.Label(filter_card, text="Nh·∫≠p danh s√°ch BmID (m·ªói d√≤ng 1 BmID):", 
                 style='Modern.TLabel').pack(anchor=tk.W, pady=(0, 10))
        
        self.filter_bmid_text = tk.Text(filter_card, height=6, font=('Consolas', 10),
                                       relief='solid', borderwidth=2, padx=10, pady=8)
        self.filter_bmid_text.pack(fill=tk.X, pady=(0, 15))
        
        ttk.Button(filter_card, text="üîç L·ªçc ngay", style='Primary.TButton',
                  command=self.filter_links_by_bmid).pack(anchor=tk.W)
        
        # Results card
        results_card = ttk.Frame(filter_container, style='Card.TFrame')
        results_card.pack(fill=tk.BOTH, expand=True)
        
        results_title = ttk.Label(results_card, text="üìã K·∫øt qu·∫£ l·ªçc", style='Subtitle.TLabel')
        results_title.pack(anchor=tk.W, pady=(0, 15))
        
        results_container = ttk.Frame(results_card, style='Modern.TFrame')
        results_container.pack(fill=tk.BOTH, expand=True)
        results_container.columnconfigure(0, weight=1)
        results_container.columnconfigure(1, weight=1)
        results_container.rowconfigure(1, weight=1)
        
        # Result lists
        ttk.Label(results_container, text="üîó Link 1", style='Subtitle.TLabel').grid(row=0, column=0, sticky=tk.W, pady=(0, 10))
        ttk.Label(results_container, text="üîó Link 2", style='Subtitle.TLabel').grid(row=0, column=1, sticky=tk.W, padx=(20, 0), pady=(0, 10))
        
        self.list_link1 = tk.Listbox(results_container, font=('Consolas', 9), 
                                    relief='solid', borderwidth=2)
        self.list_link2 = tk.Listbox(results_container, font=('Consolas', 9),
                                    relief='solid', borderwidth=2)
        
        self.list_link1.grid(row=1, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), padx=(0, 10))
        self.list_link2.grid(row=1, column=1, sticky=(tk.W, tk.E, tk.N, tk.S), padx=(10, 0))
        
        # Scrollbars for lists
        sb1 = ttk.Scrollbar(results_container, orient=tk.VERTICAL, command=self.list_link1.yview)
        self.list_link1.configure(yscrollcommand=sb1.set)
        sb1.grid(row=1, column=0, sticky=(tk.N, tk.S, tk.E))
        
        sb2 = ttk.Scrollbar(results_container, orient=tk.VERTICAL, command=self.list_link2.yview)
        self.list_link2.configure(yscrollcommand=sb2.set)
        sb2.grid(row=1, column=1, sticky=(tk.N, tk.S, tk.E))
        
        # Filter info
        self.filter_info_var = tk.StringVar(value="Ch∆∞a c√≥ k·∫øt qu·∫£ l·ªçc")
        info_label = ttk.Label(results_card, textvariable=self.filter_info_var, 
                             style='Modern.TLabel', font=('Segoe UI', 10, 'italic'))
        info_label.pack(anchor=tk.W, pady=(15, 0))
        
    # Keep all the existing methods from the original code...
    def refresh_folders(self):
        """L√†m m·ªõi danh s√°ch th∆∞ m·ª•c"""
        try:
            folders = [f for f in os.listdir(self.data_dir) if os.path.isdir(os.path.join(self.data_dir, f))]
            folders.sort()
            self.folder_combo['values'] = folders
            if self.current_folder not in folders:
                self.current_folder = 'default'
                self.folder_var.set(self.current_folder)
            self.update_folder_info()
            self.update_status_bar()
        except Exception as e:
            messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ t·∫£i danh s√°ch th∆∞ m·ª•c: {str(e)}")
            
    def update_folder_info(self):
        """C·∫≠p nh·∫≠t th√¥ng tin th∆∞ m·ª•c hi·ªán t·∫°i"""
        try:
            folder_path = os.path.join(self.data_dir, self.current_folder)
            bm_count = len(self.bm_data)
            self.folder_info_var.set(f"üìÇ Th∆∞ m·ª•c: {self.current_folder} | üìä S·ªë BM: {bm_count}")
        except Exception:
            self.folder_info_var.set(f"üìÇ Th∆∞ m·ª•c: {self.current_folder} | üìä S·ªë BM: 0")

    def on_folder_change(self, event=None):
        """X·ª≠ l√Ω khi thay ƒë·ªïi th∆∞ m·ª•c"""
        new_folder = self.folder_var.get()
        if new_folder != self.current_folder:
            self.save_json_db()
            self.current_folder = new_folder
            self.db_path = os.path.join(self.data_dir, self.current_folder, 'bm_data.json')
            self.load_json_db()
            self.update_folder_info()

    def create_folder(self):
        """T·∫°o th∆∞ m·ª•c m·ªõi"""
        folder_name = simpledialog.askstring("T·∫°o th∆∞ m·ª•c", "Nh·∫≠p t√™n th∆∞ m·ª•c m·ªõi:")
        if folder_name and folder_name.strip():
            folder_name = folder_name.strip()
            folder_path = os.path.join(self.data_dir, folder_name)
            try:
                if os.path.exists(folder_path):
                    messagebox.showwarning("C·∫£nh b√°o", "Th∆∞ m·ª•c ƒë√£ t·ªìn t·∫°i!")
                    return
                os.makedirs(folder_path)
                self.refresh_folders()
                messagebox.showinfo("Th√†nh c√¥ng", f"‚úÖ ƒê√£ t·∫°o th∆∞ m·ª•c: {folder_name}")
            except Exception as e:
                messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ t·∫°o th∆∞ m·ª•c: {str(e)}")

    def delete_folder(self):
        """X√≥a th∆∞ m·ª•c"""
        if self.current_folder == 'default':
            messagebox.showwarning("C·∫£nh b√°o", "Kh√¥ng th·ªÉ x√≥a th∆∞ m·ª•c m·∫∑c ƒë·ªãnh!")
            return
            
        if messagebox.askyesno("X√°c nh·∫≠n", f"B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a th∆∞ m·ª•c '{self.current_folder}'?"):
            try:
                folder_path = os.path.join(self.data_dir, self.current_folder)
                if os.path.exists(folder_path):
                    shutil.rmtree(folder_path)
                self.current_folder = 'default'
                self.folder_var.set(self.current_folder)
                self.db_path = os.path.join(self.data_dir, self.current_folder, 'bm_data.json')
                self.refresh_folders()
                self.load_json_db()
                messagebox.showinfo("Th√†nh c√¥ng", "‚úÖ ƒê√£ x√≥a th∆∞ m·ª•c!")
            except Exception as e:
                messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ x√≥a th∆∞ m·ª•c: {str(e)}")

    def rename_folder(self):
        """ƒê·ªïi t√™n th∆∞ m·ª•c"""
        if self.current_folder == 'default':
            messagebox.showwarning("C·∫£nh b√°o", "Kh√¥ng th·ªÉ ƒë·ªïi t√™n th∆∞ m·ª•c m·∫∑c ƒë·ªãnh!")
            return
            
        new_name = simpledialog.askstring("ƒê·ªïi t√™n th∆∞ m·ª•c", f"T√™n m·ªõi cho th∆∞ m·ª•c '{self.current_folder}':")
        if new_name and new_name.strip():
            new_name = new_name.strip()
            if new_name == self.current_folder:
                return
            try:
                old_path = os.path.join(self.data_dir, self.current_folder)
                new_path = os.path.join(self.data_dir, new_name)
                if os.path.exists(new_path):
                    messagebox.showwarning("C·∫£nh b√°o", "T√™n th∆∞ m·ª•c ƒë√£ t·ªìn t·∫°i!")
                    return
                os.rename(old_path, new_path)
                self.current_folder = new_name
                self.folder_var.set(self.current_folder)
                self.db_path = os.path.join(self.data_dir, self.current_folder, 'bm_data.json')
                self.refresh_folders()
                messagebox.showinfo("Th√†nh c√¥ng", f"‚úÖ ƒê√£ ƒë·ªïi t√™n th∆∞ m·ª•c th√†nh: {new_name}")
            except Exception as e:
                messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ ƒë·ªïi t√™n th∆∞ m·ª•c: {str(e)}")

    def move_selected(self):
        """Di chuy·ªÉn d·ªØ li·ªáu ƒë√£ ch·ªçn sang th∆∞ m·ª•c kh√°c"""
        selection = self.tree.selection()
        if not selection:
            messagebox.showwarning("C·∫£nh b√°o", "Vui l√≤ng ch·ªçn d·ªØ li·ªáu c·∫ßn di chuy·ªÉn!")
            return
            
        # L·∫•y danh s√°ch th∆∞ m·ª•c c√≥ s·∫µn (tr·ª´ th∆∞ m·ª•c hi·ªán t·∫°i)
        try:
            folders = [f for f in os.listdir(self.data_dir) if os.path.isdir(os.path.join(self.data_dir, f))]
            folders = [f for f in folders if f != self.current_folder]
            folders.sort()
            
            if not folders:
                messagebox.showwarning("C·∫£nh b√°o", "Kh√¥ng c√≥ th∆∞ m·ª•c n√†o kh√°c ƒë·ªÉ di chuy·ªÉn!")
                return
                
            # T·∫°o dialog ch·ªçn th∆∞ m·ª•c ƒë√≠ch v·ªõi giao di·ªán ƒë·∫πp
            move_window = tk.Toplevel(self.root)
            move_window.title("üì¶ Di chuy·ªÉn d·ªØ li·ªáu")
            move_window.geometry("800x800")
            move_window.transient(self.root)
            move_window.grab_set()
            move_window.configure(bg=self.colors['bg_secondary'])
            
            # Center window
            move_window.update_idletasks()
            x = (move_window.winfo_screenwidth() // 2) - (800 // 2)
            y = (move_window.winfo_screenheight() // 2) - (800 // 2)
            move_window.geometry(f"800x800+{x}+{y}")
            
            # Main container
            main_container = ttk.Frame(move_window, style='Modern.TFrame')
            main_container.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
            
            # Header card
            header_card = ttk.Frame(main_container, style='Card.TFrame')
            header_card.pack(fill=tk.X, pady=(0, 20))
            
            # Title
            title_label = ttk.Label(header_card, text="üì¶ Di chuy·ªÉn d·ªØ li·ªáu", style='Title.TLabel')
            title_label.pack(pady=(0, 10))
            
            # Info
            info_text = f"üìä S·ªë d√≤ng ƒë√£ ch·ªçn: {len(selection)}\nüìÇ T·ª´ th∆∞ m·ª•c: {self.current_folder}"
            ttk.Label(header_card, text=info_text, style='Modern.TLabel', 
                     font=('Segoe UI', 11, 'bold')).pack(anchor=tk.W, pady=(0, 10))
            
            # Destination selection card
            dest_card = ttk.Frame(main_container, style='Card.TFrame')
            dest_card.pack(fill=tk.X, pady=(0, 20))
            
            dest_title = ttk.Label(dest_card, text="üéØ Ch·ªçn th∆∞ m·ª•c ƒë√≠ch", style='Subtitle.TLabel')
            dest_title.pack(anchor=tk.W, pady=(0, 15))
            
            dest_label = ttk.Label(dest_card, text="Th∆∞ m·ª•c ƒë√≠ch:", style='Modern.TLabel')
            dest_label.pack(anchor=tk.W, pady=(0, 8))
            
            dest_folder_var = tk.StringVar()
            dest_combo = ttk.Combobox(dest_card, textvariable=dest_folder_var, values=folders, 
                                    width=40, state='readonly', style='Modern.TCombobox',
                                    font=('Segoe UI', 11))
            dest_combo.pack(fill=tk.X, pady=(0, 15))
            
            # Warning info
            warning_text = "‚ö†Ô∏è D·ªØ li·ªáu s·∫Ω ƒë∆∞·ª£c x√≥a kh·ªèi th∆∞ m·ª•c hi·ªán t·∫°i sau khi di chuy·ªÉn"
            ttk.Label(dest_card, text=warning_text, style='Modern.TLabel', 
                     foreground=self.colors['danger'], font=('Segoe UI', 10, 'italic')).pack(anchor=tk.W)
            
            # Mode selection card
            mode_card = ttk.Frame(main_container, style='Card.TFrame')
            mode_card.pack(fill=tk.X, pady=(0, 20))
            
            mode_title = ttk.Label(mode_card, text="‚öôÔ∏è Ph·∫°m vi di chuy·ªÉn", style='Subtitle.TLabel')
            mode_title.pack(anchor=tk.W, pady=(0, 15))
            
            self.move_mode_var = tk.StringVar(value='all')
            
            # Mode options with better styling
            mode_options = [
                ('all', 'üìã To√†n b·ªô (Link1 + Link2 + Link3)', 'Di chuy·ªÉn t·∫•t c·∫£ links c·ªßa m·ªói record'),
                ('l1', 'üîó Ch·ªâ Link 1', 'Ch·ªâ di chuy·ªÉn Link1, gi·ªØ l·∫°i Link2, Link3'),
                ('l2', 'üîó Ch·ªâ Link 2', 'Ch·ªâ di chuy·ªÉn Link2, gi·ªØ l·∫°i Link1, Link3'),
                ('l3', 'üîó Ch·ªâ Link 3', 'Ch·ªâ di chuy·ªÉn Link3, gi·ªØ l·∫°i Link1, Link2')
            ]
            
            for value, text, desc in mode_options:
                option_frame = ttk.Frame(mode_card)
                option_frame.pack(fill=tk.X, pady=5)
                
                radio = ttk.Radiobutton(option_frame, text=text, value=value, variable=self.move_mode_var,
                                      style='Modern.TRadiobutton')
                radio.pack(side=tk.LEFT)
                
                desc_label = ttk.Label(option_frame, text=desc, style='Modern.TLabel',
                                     foreground=self.colors['text_secondary'], font=('Segoe UI', 9, 'italic'))
                desc_label.pack(side=tk.LEFT, padx=(10, 0))

            # Buttons card
            button_card = ttk.Frame(main_container, style='Card.TFrame')
            button_card.pack(fill=tk.X)
            
            button_frame = ttk.Frame(button_card, style='Modern.TFrame')
            button_frame.pack(fill=tk.X)
            
            def confirm_move():
                dest_folder = dest_folder_var.get()
                if not dest_folder:
                    messagebox.showwarning("C·∫£nh b√°o", "Vui l√≤ng ch·ªçn th∆∞ m·ª•c ƒë√≠ch!")
                    return
                    
                if messagebox.askyesno("X√°c nh·∫≠n", 
                    f"B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën di chuy·ªÉn {len(selection)} d√≤ng sang th∆∞ m·ª•c '{dest_folder}'?"):
                    self.perform_move(selection, dest_folder, self.move_mode_var.get())
                    move_window.destroy()
            
            # Buttons with better spacing
            ttk.Button(button_frame, text="‚úÖ X√°c nh·∫≠n di chuy·ªÉn", style='Primary.TButton',
                      command=confirm_move).pack(side=tk.LEFT, padx=(0, 15))
            ttk.Button(button_frame, text="‚ùå H·ªßy b·ªè", style='Danger.TButton',
                      command=move_window.destroy).pack(side=tk.LEFT)
            
        except Exception as e:
            messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ t·∫°o dialog di chuy·ªÉn: {str(e)}")
            
    def perform_move(self, selection, dest_folder, mode='all'):
        """Th·ª±c hi·ªán di chuy·ªÉn d·ªØ li·ªáu v·ªõi ch·∫ø ƒë·ªô: all | l1 | l2 | l3 - T·ªëi ∆∞u t·ªëc ƒë·ªô"""
        try:
            # Hi·ªÉn th·ªã cursor ch·ªù
            self.tree.config(cursor="wait")
            self.root.update()
            
            # L·∫•y d·ªØ li·ªáu c·∫ßn di chuy·ªÉn - t·ªëi ∆∞u v·ªõi batch processing
            indices = [self.tree.index(item) for item in selection]
            indices.sort(reverse=True)  # X√≥a t·ª´ cu·ªëi l√™n
            
            data_to_move = []
            items_to_remove = []
            
            # X·ª≠ l√Ω batch ƒë·ªÉ tƒÉng t·ªëc
            for idx in indices:
                rec = self.bm_data[idx]
                # Chu·∫©n h√≥a rec th√†nh dict Link1..3
                if not isinstance(rec, dict):
                    rec = {'TypeBM': rec[0] if len(rec)>0 else '', 'ID': rec[1] if len(rec)>1 else '', 'BmID': rec[2] if len(rec)>2 else '', 'Link1': rec[3] if len(rec)>3 else '', 'Link2': '', 'Link3': '', 'Note': ''}
                
                if mode == 'all':
                    data_to_move.append({k: rec.get(k, '') for k in ['TypeBM','ID','BmID','Link1','Link2','Link3','Note']})
                    items_to_remove.append(idx)
                else:
                    # x√°c ƒë·ªãnh index link
                    link_map = {'l1':'Link1','l2':'Link2','l3':'Link3'}
                    link_key = link_map.get(mode, 'Link1')
                    link_val = rec.get(link_key, '')
                    if link_val:
                        # record ch·ªâ ch·ª©a 1 link ƒë∆∞·ª£c copy sang ƒë√≠ch (·ªü Link1)
                        data_to_move.append({'TypeBM': rec.get('TypeBM',''), 'ID': rec.get('ID',''), 'BmID': rec.get('BmID',''), 'Link1': link_val, 'Link2': '', 'Link3': '', 'Note': rec.get('Note','')})
                        # lo·∫°i b·ªè link kh·ªèi ngu·ªìn v√† d·ªìn l√™n
                        links = [rec.get('Link1',''), rec.get('Link2',''), rec.get('Link3','')]
                        idx_map = {'l1':0,'l2':1,'l3':2}
                        rm_i = idx_map.get(mode,0)
                        # x√≥a v·ªã tr√≠ rm_i v√† th√™m '' ·ªü cu·ªëi ƒë·ªÉ gi·ªØ 3 ph·∫ßn t·ª≠
                        links.pop(rm_i)
                        links.append('')
                        rec['Link1'], rec['Link2'], rec['Link3'] = links[0], links[1], links[2]
                        # N·∫øu c·∫£ 3 link ƒë·ªÅu r·ªóng th√¨ x√≥a b·∫£n ghi
                        if not any(links):
                            items_to_remove.append(idx)
                        else:
                            self.bm_data[idx] = rec
            
            # X√≥a batch items
            for idx in items_to_remove:
                del self.bm_data[idx]
            
            # L∆∞u th∆∞ m·ª•c hi·ªán t·∫°i
            self.save_json_db()
            
            # T·∫£i d·ªØ li·ªáu th∆∞ m·ª•c ƒë√≠ch - t·ªëi ∆∞u I/O
            dest_path = os.path.join(self.data_dir, dest_folder, 'bm_data.json')
            dest_data = []
            if os.path.exists(dest_path):
                with open(dest_path, 'r', encoding='utf-8') as f:
                    dest_data = json.load(f)
            
            # Chu·∫©n h√≥a dest_data th√†nh list[dict] - t·ªëi ∆∞u v·ªõi list comprehension
            normalized_dest = []
            for d in dest_data:
                if isinstance(d, dict):
                    normalized_dest.append({
                        'TypeBM': d.get('TypeBM',''), 'ID': d.get('ID',''), 'BmID': d.get('BmID',''),
                        'Link1': d.get('Link1', d.get('Link','')), 'Link2': d.get('Link2',''), 'Link3': d.get('Link3',''),
                        'Note': d.get('Note','')
                    })
                else:
                    if d and len(d) >= 4:
                        normalized_dest.append({'TypeBM': d[0], 'ID': d[1], 'BmID': d[2], 'Link1': d[3], 'Link2': '', 'Link3': '', 'Note': ''})
            dest_data = normalized_dest

            # Merge v√†o th∆∞ m·ª•c ƒë√≠ch theo kh√≥a v√† l·∫•p slot link tr·ªëng, tr√°nh tr√πng - t·ªëi ∆∞u v·ªõi dict lookup
            key_to_idx = {(r['TypeBM'], r['ID'], r['BmID']): i for i, r in enumerate(dest_data)}
            for m in data_to_move:
                key = (m.get('TypeBM',''), m.get('ID',''), m.get('BmID',''))
                if key in key_to_idx:
                    base = dest_data[key_to_idx[key]]
                    for lk in ['Link1','Link2','Link3']:
                        val = m.get(lk, '')
                        if not val:
                            continue
                        if val in [base.get('Link1',''), base.get('Link2',''), base.get('Link3','')]:
                            continue
                        # nh√©t v√†o slot tr·ªëng
                        if not base.get('Link1'): base['Link1'] = val; continue
                        if not base.get('Link2'): base['Link2'] = val; continue
                        if not base.get('Link3'): base['Link3'] = val; continue
                else:
                    dest_data.append({
                        'TypeBM': m.get('TypeBM',''), 'ID': m.get('ID',''), 'BmID': m.get('BmID',''),
                        'Link1': m.get('Link1',''), 'Link2': m.get('Link2',''), 'Link3': m.get('Link3',''),
                        'Note': m.get('Note','')
                    })
            
            # L∆∞u th∆∞ m·ª•c ƒë√≠ch
            with open(dest_path, 'w', encoding='utf-8') as f:
                json.dump(dest_data, f, ensure_ascii=False, indent=2)
            
            # C·∫≠p nh·∫≠t giao di·ªán
            self.refresh_tree()
            self.update_folder_info()
            self.tree.config(cursor="")
            
            messagebox.showinfo("Th√†nh c√¥ng", 
                f"ƒê√£ di chuy·ªÉn {len(data_to_move)} d√≤ng sang th∆∞ m·ª•c '{dest_folder}'!")
                
        except Exception as e:
            self.tree.config(cursor="")
            messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ di chuy·ªÉn d·ªØ li·ªáu: {str(e)}")

    def filter_links_by_bmid(self):
        """L·ªçc link theo danh s√°ch BmID"""
        text = self.filter_bmid_text.get('1.0', tk.END).strip()
        if not text:
            messagebox.showwarning("C·∫£nh b√°o", "Vui l√≤ng nh·∫≠p danh s√°ch BmID!")
            return
        bmid_list = [s.strip() for s in text.splitlines() if s.strip()]
        if not bmid_list:
            messagebox.showwarning("C·∫£nh b√°o", "Danh s√°ch BmID tr·ªëng!")
            return
        
        # Clear results
        self.list_link1.delete(0, tk.END)
        self.list_link2.delete(0, tk.END)
        
        # Filter logic (simplified version)
        found_links1 = []
        found_links2 = []
        
        for item in self.bm_data:
            if isinstance(item, dict):
                if item.get('BmID', '').strip() in bmid_list:
                    if item.get('Link1'):
                        found_links1.append(item.get('Link1'))
                    if item.get('Link2'):
                        found_links2.append(item.get('Link2'))
        
        # Add to lists
        for link in found_links1:
            self.list_link1.insert(tk.END, link)
        for link in found_links2:
            self.list_link2.insert(tk.END, link)
        
        self.filter_info_var.set(f"‚úÖ T√¨m th·∫•y: Link1: {len(found_links1)} | Link2: {len(found_links2)}")

    def create_context_menu(self):
        """T·∫°o context menu cho Treeview"""
        self.context_menu = tk.Menu(self.root, tearoff=0)
        self.context_menu.add_command(label="‚úÖ Ch·ªçn t·∫•t c·∫£", command=self.select_all)
        self.context_menu.add_command(label="üéØ Ch·ªçn theo ƒëi·ªÅu ki·ªán", command=self.show_select_menu)
        self.context_menu.add_command(label="üìù Nh·∫≠p d·ªØ li·ªáu", command=self.open_bulk_modal)
        self.context_menu.add_separator()
        self.context_menu.add_command(label="üìã Copy d·ªØ li·ªáu", command=self.open_copy_dialog)
        self.context_menu.add_command(label="üìù Th√™m ghi ch√∫", command=self.add_note_to_selected)
        self.context_menu.add_command(label="üóëÔ∏è X√≥a ƒë√£ ch·ªçn", command=self.delete_selected)
        self.context_menu.add_command(label="‚ùå B·ªè ch·ªçn t·∫•t c·∫£", command=self.unselect_all)
        
        self.tree.bind("<Button-3>", self.show_context_menu)
        
    def show_context_menu(self, event):
        """Hi·ªÉn th·ªã context menu"""
        try:
            self.context_menu.tk_popup(event.x_root, event.y_root)
        finally:
            self.context_menu.grab_release()

    def show_select_menu(self):
        """Hi·ªÉn th·ªã menu ch·ªçn d·ªØ li·ªáu v·ªõi giao di·ªán ƒë·∫πp"""
        select_window = tk.Toplevel(self.root)
        select_window.title("üéØ Ch·ªçn d·ªØ li·ªáu theo ƒëi·ªÅu ki·ªán")
        select_window.geometry("800x800")
        select_window.transient(self.root)
        select_window.grab_set()
        select_window.configure(bg=self.colors['bg_secondary'])
        
        # Center window
        select_window.update_idletasks()
        x = (select_window.winfo_screenwidth() // 2) - (800 // 2)
        y = (select_window.winfo_screenheight() // 2) - (800 // 2)
        select_window.geometry(f"800x800+{x}+{y}")
        
        # Main container
        main_container = ttk.Frame(select_window, style='Modern.TFrame')
        main_container.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
        
        # Header card
        header_card = ttk.Frame(main_container, style='Card.TFrame')
        header_card.pack(fill=tk.X, pady=(0, 20))
        
        # Title
        title_label = ttk.Label(header_card, text="üéØ Ch·ªçn d·ªØ li·ªáu theo ƒëi·ªÅu ki·ªán", style='Title.TLabel')
        title_label.pack(pady=(0, 10))
        
        # Info
        info_text = "Ch·ªçn d·ªØ li·ªáu theo c√°c ti√™u ch√≠ kh√°c nhau ƒë·ªÉ thao t√°c h√†ng lo·∫°t"
        ttk.Label(header_card, text=info_text, style='Modern.TLabel', 
                 font=('Segoe UI', 11, 'bold')).pack(anchor=tk.W, pady=(0, 10))
        
        # Selection options grid (2x2 layout)
        options_grid = ttk.Frame(main_container, style='Modern.TFrame')
        options_grid.pack(fill=tk.BOTH, expand=True, pady=(0, 20))
        options_grid.columnconfigure(0, weight=1)
        options_grid.columnconfigure(1, weight=1)
        options_grid.rowconfigure(0, weight=1)
        options_grid.rowconfigure(1, weight=1)
        
        # Type BM selection card (Top Left)
        type_card = ttk.Frame(options_grid, style='Card.TFrame')
        type_card.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), padx=(0, 10), pady=(0, 10))
        
        type_title = ttk.Label(type_card, text="üìä Ch·ªçn theo Type BM", style='Subtitle.TLabel')
        type_title.pack(anchor=tk.W, pady=(0, 15))
        
        type_info = ttk.Label(type_card, text="Nh·∫≠p Type BM ƒë·ªÉ ch·ªçn t·∫•t c·∫£ d√≤ng c√≥ c√πng lo·∫°i:", 
                             style='Modern.TLabel', font=('Segoe UI', 10))
        type_info.pack(anchor=tk.W, pady=(0, 10))
        
        type_input_frame = ttk.Frame(type_card)
        type_input_frame.pack(fill=tk.X)
        
        self.type_select_var = tk.StringVar()
        type_entry = ttk.Entry(type_input_frame, textvariable=self.type_select_var, 
                              style='Modern.TEntry', width=30, font=('Segoe UI', 11))
        type_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))
        ttk.Button(type_input_frame, text="‚úÖ Ch·ªçn", style='Success.TButton',
                  command=self.select_by_type).pack(side=tk.RIGHT)
        
        # ID selection card (Top Right)
        id_card = ttk.Frame(options_grid, style='Card.TFrame')
        id_card.grid(row=0, column=1, sticky=(tk.W, tk.E, tk.N, tk.S), padx=(10, 0), pady=(0, 10))
        
        id_title = ttk.Label(id_card, text="üÜî Ch·ªçn theo ID", style='Subtitle.TLabel')
        id_title.pack(anchor=tk.W, pady=(0, 15))
        
        id_info = ttk.Label(id_card, text="Nh·∫≠p danh s√°ch ID (m·ªói ID m·ªôt d√≤ng):", 
                           style='Modern.TLabel', font=('Segoe UI', 10))
        id_info.pack(anchor=tk.W, pady=(0, 10))
        
        self.id_select_text = tk.Text(id_card, height=6, font=('Consolas', 10),
                                     relief='solid', borderwidth=2, padx=8, pady=6)
        self.id_select_text.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        ttk.Button(id_card, text="‚úÖ Ch·ªçn theo ID", style='Success.TButton',
                  command=self.select_by_id).pack(anchor=tk.W)
        
        # BmID selection card (Bottom Left)
        bmid_card = ttk.Frame(options_grid, style='Card.TFrame')
        bmid_card.grid(row=1, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), padx=(0, 10), pady=(10, 0))
        
        bmid_title = ttk.Label(bmid_card, text="üî¢ Ch·ªçn theo BmID", style='Subtitle.TLabel')
        bmid_title.pack(anchor=tk.W, pady=(0, 15))
        
        bmid_info = ttk.Label(bmid_card, text="Nh·∫≠p danh s√°ch BmID (m·ªói BmID m·ªôt d√≤ng):", 
                             style='Modern.TLabel', font=('Segoe UI', 10))
        bmid_info.pack(anchor=tk.W, pady=(0, 10))
        
        self.bmid_select_text = tk.Text(bmid_card, height=6, font=('Consolas', 10),
                                       relief='solid', borderwidth=2, padx=8, pady=6)
        self.bmid_select_text.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        ttk.Button(bmid_card, text="‚úÖ Ch·ªçn theo BmID", style='Success.TButton',
                  command=self.select_by_bmid).pack(anchor=tk.W)
        
        # Link selection card (Bottom Right)
        link_card = ttk.Frame(options_grid, style='Card.TFrame')
        link_card.grid(row=1, column=1, sticky=(tk.W, tk.E, tk.N, tk.S), padx=(10, 0), pady=(10, 0))
        
        link_title = ttk.Label(link_card, text="üîó Ch·ªçn theo Link", style='Subtitle.TLabel')
        link_title.pack(anchor=tk.W, pady=(0, 15))
        
        link_info = ttk.Label(link_card, text="Nh·∫≠p danh s√°ch Link (m·ªói Link m·ªôt d√≤ng):", 
                             style='Modern.TLabel', font=('Segoe UI', 10))
        link_info.pack(anchor=tk.W, pady=(0, 10))
        
        self.link_select_text = tk.Text(link_card, height=6, font=('Consolas', 10),
                                       relief='solid', borderwidth=2, padx=8, pady=6)
        self.link_select_text.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        ttk.Button(link_card, text="‚úÖ Ch·ªçn theo Link", style='Success.TButton',
                  command=self.select_by_link).pack(anchor=tk.W)
        
        # Close button card
        button_card = ttk.Frame(main_container, style='Card.TFrame')
        button_card.pack(fill=tk.X)
        
        ttk.Button(button_card, text="‚ùå ƒê√≥ng", style='Danger.TButton',
                  command=select_window.destroy).pack()

    def select_by_type(self):
        """Ch·ªçn theo Type BM - T·ªëi ∆∞u t·ªëc ƒë·ªô"""
        type_to_select = self.type_select_var.get().strip()
        if not type_to_select:
            messagebox.showwarning("C·∫£nh b√°o", "Vui l√≤ng nh·∫≠p Type BM!")
            return
            
        # T·∫Øt c·∫≠p nh·∫≠t giao di·ªán
        self.tree.config(cursor="wait")
        self.root.update()
        
        # T√¨m t·∫•t c·∫£ items ph√π h·ª£p tr∆∞·ªõc
        matching_items = []
        tree_items = list(self.tree.get_children())
        
        for i, item in enumerate(self.bm_data):
            type_bm = item.get('TypeBM', '') if isinstance(item, dict) else (item[0] if len(item) > 0 else '')
            if type_bm.strip() == type_to_select and i < len(tree_items):
                matching_items.append(tree_items[i])
        
        # Ch·ªçn t·∫•t c·∫£ c√πng l√∫c
        if matching_items:
            self.tree.selection_set(matching_items)
        
        # C·∫≠p nh·∫≠t hi·ªÉn th·ªã m·ªôt l·∫ßn
        self.update_checkbox_display()
        self.tree.config(cursor="")
        
        messagebox.showinfo("Th√†nh c√¥ng", f"‚úÖ ƒê√£ ch·ªçn {len(matching_items)} d√≤ng c√≥ Type BM: {type_to_select}")

    def select_by_id(self):
        """Ch·ªçn theo danh s√°ch ID - T·ªëi ∆∞u t·ªëc ƒë·ªô"""
        ids_text = self.id_select_text.get('1.0', tk.END).strip()
        if not ids_text:
            messagebox.showwarning("C·∫£nh b√°o", "Vui l√≤ng nh·∫≠p danh s√°ch ID!")
            return
            
        # T·∫Øt c·∫≠p nh·∫≠t giao di·ªán
        self.tree.config(cursor="wait")
        self.root.update()
        
        ids = set(id.strip() for id in ids_text.splitlines() if id.strip())
        matching_items = []
        tree_items = list(self.tree.get_children())
        
        for i, item in enumerate(self.bm_data):
            item_id = item.get('ID', '') if isinstance(item, dict) else (item[1] if len(item) > 1 else '')
            if item_id.strip() in ids and i < len(tree_items):
                matching_items.append(tree_items[i])
        
        # Ch·ªçn t·∫•t c·∫£ c√πng l√∫c
        if matching_items:
            self.tree.selection_set(matching_items)
        
        # C·∫≠p nh·∫≠t hi·ªÉn th·ªã m·ªôt l·∫ßn
        self.update_checkbox_display()
        self.tree.config(cursor="")
        
        messagebox.showinfo("Th√†nh c√¥ng", f"‚úÖ ƒê√£ ch·ªçn {len(matching_items)} d√≤ng theo ID")

    def select_by_bmid(self):
        """Ch·ªçn theo danh s√°ch BmID - T·ªëi ∆∞u t·ªëc ƒë·ªô"""
        bmids_text = self.bmid_select_text.get('1.0', tk.END).strip()
        if not bmids_text:
            messagebox.showwarning("C·∫£nh b√°o", "Vui l√≤ng nh·∫≠p danh s√°ch BmID!")
            return
            
        # T·∫Øt c·∫≠p nh·∫≠t giao di·ªán
        self.tree.config(cursor="wait")
        self.root.update()
        
        bmids = set(bmid.strip() for bmid in bmids_text.splitlines() if bmid.strip())
        matching_items = []
        tree_items = list(self.tree.get_children())
        
        for i, item in enumerate(self.bm_data):
            bmid = item.get('BmID', '') if isinstance(item, dict) else (item[2] if len(item) > 2 else '')
            if bmid.strip() in bmids and i < len(tree_items):
                matching_items.append(tree_items[i])
        
        # Ch·ªçn t·∫•t c·∫£ c√πng l√∫c
        if matching_items:
            self.tree.selection_set(matching_items)
        
        # C·∫≠p nh·∫≠t hi·ªÉn th·ªã m·ªôt l·∫ßn
        self.update_checkbox_display()
        self.tree.config(cursor="")
        
        messagebox.showinfo("Th√†nh c√¥ng", f"‚úÖ ƒê√£ ch·ªçn {len(matching_items)} d√≤ng theo BmID")

    def select_by_link(self):
        """Ch·ªçn theo danh s√°ch Link - T·ªëi ∆∞u t·ªëc ƒë·ªô"""
        links_text = self.link_select_text.get('1.0', tk.END).strip()
        if not links_text:
            messagebox.showwarning("C·∫£nh b√°o", "Vui l√≤ng nh·∫≠p danh s√°ch Link!")
            return
            
        # T·∫Øt c·∫≠p nh·∫≠t giao di·ªán
        self.tree.config(cursor="wait")
        self.root.update()
        
        links = set(link.strip() for link in links_text.splitlines() if link.strip())
        matching_items = []
        tree_items = list(self.tree.get_children())
        
        for i, item in enumerate(self.bm_data):
            if isinstance(item, dict):
                item_links = [item.get('Link1', ''), item.get('Link2', ''), item.get('Link3', '')]
            else:
                item_links = [item[3] if len(item) > 3 else '']
                
            if any(link in links for link in item_links if link) and i < len(tree_items):
                matching_items.append(tree_items[i])
        
        # Ch·ªçn t·∫•t c·∫£ c√πng l√∫c
        if matching_items:
            self.tree.selection_set(matching_items)
        
        # C·∫≠p nh·∫≠t hi·ªÉn th·ªã m·ªôt l·∫ßn
        self.update_checkbox_display()
        self.tree.config(cursor="")
        
        messagebox.showinfo("Th√†nh c√¥ng", f"‚úÖ ƒê√£ ch·ªçn {len(matching_items)} d√≤ng theo Link")

    def delete_selected(self):
        """X√≥a c√°c d√≤ng ƒë√£ ch·ªçn"""
        selection = self.tree.selection()
        if not selection:
            messagebox.showwarning("C·∫£nh b√°o", "Vui l√≤ng ch·ªçn d√≤ng c·∫ßn x√≥a!")
            return
            
        if messagebox.askyesno("X√°c nh·∫≠n", f"B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a {len(selection)} d√≤ng ƒë√£ ch·ªçn?"):
            indices = sorted([self.rowid_to_index.get(item, -1) for item in selection 
                            if self.rowid_to_index.get(item, -1) >= 0], reverse=True)
            
            for index in indices:
                del self.bm_data[index]
                
            self.refresh_tree()
            self.save_json_db()
            messagebox.showinfo("Th√†nh c√¥ng", f"‚úÖ ƒê√£ x√≥a {len(selection)} d√≤ng!")

    def select_all(self):
        """Ch·ªçn t·∫•t c·∫£ d√≤ng - T·ªëi ∆∞u t·ªëc ƒë·ªô"""
        all_items = self.tree.get_children()
        if not all_items:
            return
            
        # T·∫Øt c·∫≠p nh·∫≠t giao di·ªán trong qu√° tr√¨nh ch·ªçn
        self.tree.config(cursor="wait")
        self.root.update()
        
        # Ch·ªçn t·∫•t c·∫£ items c√πng l√∫c
        self.tree.selection_set(all_items)
        
        # C·∫≠p nh·∫≠t hi·ªÉn th·ªã m·ªôt l·∫ßn
        self.update_checkbox_display()
        self.tree.config(cursor="")
        
        messagebox.showinfo("Th√†nh c√¥ng", f"‚úÖ ƒê√£ ch·ªçn t·∫•t c·∫£ {len(all_items)} d√≤ng!")

    def unselect_all(self):
        """B·ªè ch·ªçn t·∫•t c·∫£"""
        self.tree.selection_remove(self.tree.selection())
        self.update_checkbox_display()

    def add_note_to_selected(self):
        """Th√™m ghi ch√∫ cho c√°c d√≤ng ƒë√£ ch·ªçn"""
        selection = self.tree.selection()
        if not selection:
            messagebox.showwarning("C·∫£nh b√°o", "Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt d√≤ng!")
            return
            
        note = simpledialog.askstring("Th√™m ghi ch√∫", "Nh·∫≠p n·ªôi dung ghi ch√∫:")
        if note is None:
            return
            
        note = note.strip()
        indices = []
        for item in selection:
            base_index = self.rowid_to_index.get(item, -1)
            if base_index >= 0:
                indices.append(base_index)
                
        for idx in indices:
            if isinstance(self.bm_data[idx], dict):
                self.bm_data[idx]['Note'] = note
            else:
                # Convert to dict format
                row = self.bm_data[idx]
                self.bm_data[idx] = {
                    'TypeBM': row[0] if len(row) > 0 else '',
                    'ID': row[1] if len(row) > 1 else '',
                    'BmID': row[2] if len(row) > 2 else '',
                    'Link1': row[3] if len(row) > 3 else '',
                    'Link2': '',
                    'Link3': '',
                    'Note': note,
                }
                
        self.refresh_tree()
        self.save_json_db()
        self.update_folder_info()
        messagebox.showinfo("Th√†nh c√¥ng", f"‚úÖ ƒê√£ th√™m ghi ch√∫ cho {len(indices)} d√≤ng!")

    def open_copy_dialog(self):
        """M·ªü dialog copy v·ªõi giao di·ªán ƒë·∫πp"""
        selection = self.tree.selection()
        if not selection:
            messagebox.showwarning("C·∫£nh b√°o", "Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt d√≤ng ƒë·ªÉ copy!")
            return
        
        dialog = tk.Toplevel(self.root)
        dialog.title("üìã Copy d·ªØ li·ªáu")
        dialog.geometry("800x800")
        dialog.transient(self.root)
        dialog.grab_set()
        dialog.configure(bg=self.colors['bg_secondary'])
        
        # Center window
        dialog.update_idletasks()
        x = (dialog.winfo_screenwidth() // 2) - (800 // 2)
        y = (dialog.winfo_screenheight() // 2) - (800 // 2)
        dialog.geometry(f"800x800+{x}+{y}")
        
        # Main container
        main_container = ttk.Frame(dialog, style='Modern.TFrame')
        main_container.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
        
        # Header card
        header_card = ttk.Frame(main_container, style='Card.TFrame')
        header_card.pack(fill=tk.X, pady=(0, 20))
        
        # Title
        title_label = ttk.Label(header_card, text="üìã C·∫•u h√¨nh Copy", style='Title.TLabel')
        title_label.pack(pady=(0, 10))
        
        # Info
        info_text = f"üìä S·ªë d√≤ng ƒë√£ ch·ªçn: {len(selection)}\nüìã D·ªØ li·ªáu s·∫Ω ƒë∆∞·ª£c copy v√†o clipboard"
        ttk.Label(header_card, text=info_text, style='Modern.TLabel', 
                 font=('Segoe UI', 11, 'bold')).pack(anchor=tk.W, pady=(0, 10))
        
        # Column mapping card
        mapping_card = ttk.Frame(main_container, style='Card.TFrame')
        mapping_card.pack(fill=tk.X, pady=(0, 20))
        
        mapping_title = ttk.Label(mapping_card, text="üîÄ √Ånh x·∫° c·ªôt ‚Üí tr∆∞·ªùng", style='Subtitle.TLabel')
        mapping_title.pack(anchor=tk.W, pady=(0, 15))
        
        fields = ('TypeBM', 'ID', 'BmID', 'Link1', 'Link2', 'Link3')
        self.map_vars = [tk.StringVar(value=('TypeBM','ID','BmID','Link1')[i] if i<4 else fields[i]) 
                        for i in range(4)]
        
        # Mapping grid
        mapping_grid = ttk.Frame(mapping_card)
        mapping_grid.pack(fill=tk.X)
        
        for i in range(4):
            row_frame = ttk.Frame(mapping_grid)
            row_frame.pack(fill=tk.X, pady=8)
            
            ttk.Label(row_frame, text=f"C·ªôt {i+1}:", style='Modern.TLabel', 
                     font=('Segoe UI', 11, 'bold')).pack(side=tk.LEFT, padx=(0, 15))
            cb = ttk.Combobox(row_frame, textvariable=self.map_vars[i], values=fields, 
                            width=20, state='readonly', style='Modern.TCombobox',
                            font=('Segoe UI', 11))
            cb.pack(side=tk.LEFT, padx=(0, 20))
            
            # Description
            desc_text = f"Tr∆∞·ªùng d·ªØ li·ªáu cho c·ªôt {i+1}"
            ttk.Label(row_frame, text=desc_text, style='Modern.TLabel',
                     foreground=self.colors['text_secondary'], font=('Segoe UI', 9, 'italic')).pack(side=tk.LEFT, padx=(10, 0))
        
        # Delimiter card
        delim_card = ttk.Frame(main_container, style='Card.TFrame')
        delim_card.pack(fill=tk.X, pady=(0, 20))
        
        delim_title = ttk.Label(delim_card, text="üîÄ D·∫•u ph√¢n c√°ch", style='Subtitle.TLabel')
        delim_title.pack(anchor=tk.W, pady=(0, 15))
        
        delim_info = ttk.Label(delim_card, text="K√Ω t·ª± ƒë·ªÉ ph√¢n t√°ch c√°c tr∆∞·ªùng trong m·ªói d√≤ng:", 
                              style='Modern.TLabel', font=('Segoe UI', 10))
        delim_info.pack(anchor=tk.W, pady=(0, 10))
        
        self.delim_var = tk.StringVar(value='|')
        delim_entry = ttk.Entry(delim_card, textvariable=self.delim_var, 
                               style='Modern.TEntry', width=15, font=('Segoe UI', 12))
        delim_entry.pack(anchor=tk.W, pady=(0, 10))
        
        # Examples
        examples_text = "V√≠ d·ª•: | (pipe), , (comma), ; (semicolon), \\t (tab)"
        ttk.Label(delim_card, text=examples_text, style='Modern.TLabel',
                 foreground=self.colors['text_secondary'], font=('Segoe UI', 9, 'italic')).pack(anchor=tk.W)
        
        # Buttons card
        button_card = ttk.Frame(main_container, style='Card.TFrame')
        button_card.pack(fill=tk.X)
        
        button_frame = ttk.Frame(button_card, style='Modern.TFrame')
        button_frame.pack(fill=tk.X)
        
        ttk.Button(button_frame, text="üìã Copy ngay", style='Primary.TButton',
                  command=lambda: self.perform_copy(dialog)).pack(side=tk.LEFT, padx=(0, 15))
        ttk.Button(button_frame, text="‚ùå ƒê√≥ng", style='Danger.TButton',
                  command=dialog.destroy).pack(side=tk.LEFT)

    def perform_copy(self, dialog):
        """Th·ª±c hi·ªán copy d·ªØ li·ªáu"""
        mapping = [v.get() for v in self.map_vars]
        if len(set(mapping)) != 4:
            messagebox.showerror("L·ªói", "√Ånh x·∫° 4 c·ªôt ph·∫£i l√† 4 tr∆∞·ªùng kh√°c nhau!")
            return
            
        delim = self.delim_var.get()
        if not delim:
            messagebox.showerror("L·ªói", "Vui l√≤ng nh·∫≠p d·∫•u ph√¢n c√°ch!")
            return
            
        selection = self.tree.selection()
        lines = []
        
        for item in selection:
            base_index = self.rowid_to_index.get(item, -1)
            if base_index >= 0 and base_index < len(self.bm_data):
                rec = self.bm_data[base_index]
                if not isinstance(rec, dict):
                    rec = {
                        'TypeBM': rec[0] if len(rec) > 0 else '',
                        'ID': rec[1] if len(rec) > 1 else '',
                        'BmID': rec[2] if len(rec) > 2 else '',
                        'Link1': rec[3] if len(rec) > 3 else '',
                        'Link2': '',
                        'Link3': '',
                    }
                parts = [str(rec.get(field, '')) for field in mapping]
                lines.append(delim.join(parts))
        
        text = "\n".join(lines)
        try:
            self.root.clipboard_clear()
            self.root.clipboard_append(text)
            self.root.update()
            messagebox.showinfo("Th√†nh c√¥ng", f"‚úÖ ƒê√£ copy {len(lines)} d√≤ng v√†o clipboard!")
            dialog.destroy()
        except Exception as e:
            messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ copy: {str(e)}")

    def load_json_db(self):
        """T·∫£i d·ªØ li·ªáu t·ª´ JSON DB"""
        try:
            if os.path.exists(self.db_path):
                with open(self.db_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    
                normalized = []
                for item in data:
                    if not isinstance(item, dict):
                        continue
                    normalized.append({
                        'TypeBM': str(item.get('TypeBM', '')).strip(),
                        'ID': str(item.get('ID', '')).strip(),
                        'BmID': str(item.get('BmID', '')).strip(),
                        'Link1': str(item.get('Link1', item.get('Link', ''))).strip(),
                        'Link2': str(item.get('Link2', '')).strip(),
                        'Link3': str(item.get('Link3', '')).strip(),
                        'Note': str(item.get('Note', '')).strip()
                    })
                self.bm_data = normalized
            else:
                self.bm_data = []
                
            self.refresh_tree()
            self.update_status_bar()
        except Exception as e:
            messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ t·∫£i DB JSON: {str(e)}")
            self.bm_data = []
            self.refresh_tree()
            self.update_status_bar()

    def save_json_db(self):
        """L∆∞u d·ªØ li·ªáu v√†o JSON DB"""
        try:
            os.makedirs(os.path.dirname(self.db_path), exist_ok=True)
            with open(self.db_path, 'w', encoding='utf-8') as f:
                json.dump(self.bm_data, f, ensure_ascii=False, indent=2)
            self.update_status_bar()
        except Exception as e:
            messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ l∆∞u DB JSON: {str(e)}")

    def open_bulk_modal(self):
        """M·ªü c·ª≠a s·ªï nh·∫≠p d·ªØ li·ªáu h√†ng lo·∫°t v·ªõi giao di·ªán ƒë·∫πp"""
        if hasattr(self, 'bulk_modal') and self.bulk_modal.winfo_exists():
            self.bulk_modal.deiconify()
            self.bulk_modal.lift()
            return
            
        self.bulk_modal = tk.Toplevel(self.root)
        self.bulk_modal.title("üìù Nh·∫≠p d·ªØ li·ªáu h√†ng lo·∫°t")
        self.bulk_modal.geometry("800x600")
        self.bulk_modal.transient(self.root)
        self.bulk_modal.grab_set()
        self.bulk_modal.configure(bg=self.colors['bg_secondary'])
        
        container = ttk.Frame(self.bulk_modal, style='Card.TFrame')
        container.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
        
        title = ttk.Label(container, text="üìù Nh·∫≠p d·ªØ li·ªáu h√†ng lo·∫°t", style='Title.TLabel')
        title.pack(pady=(0, 20))
        
        # Column mapping
        mapping_frame = ttk.LabelFrame(container, text="üîÄ √Ånh x·∫° c·ªôt ‚Üí tr∆∞·ªùng", padding=15)
        mapping_frame.pack(fill=tk.X, pady=(0, 15))
        
        mapping_values = ('TypeBM', 'ID', 'BmID', 'Link1')
        self.bulk_map_vars = [tk.StringVar(value=mapping_values[i]) for i in range(4)]
        
        maps_grid = ttk.Frame(mapping_frame)
        maps_grid.pack(fill=tk.X)
        
        for i in range(4):
            ttk.Label(maps_grid, text=f"C·ªôt {i+1}:", style='Modern.TLabel').grid(
                row=0, column=i*2, sticky=tk.W, padx=(0, 5))
            cb = ttk.Combobox(maps_grid, textvariable=self.bulk_map_vars[i], 
                            values=mapping_values, width=12, state='readonly', style='Modern.TCombobox')
            cb.grid(row=0, column=i*2+1, padx=(0, 15))
        
        # Delimiter
        delim_frame = ttk.Frame(mapping_frame)
        delim_frame.pack(fill=tk.X, pady=(10, 0))
        
        ttk.Label(delim_frame, text="D·∫•u ph√¢n c√°ch:", style='Modern.TLabel').pack(side=tk.LEFT)
        self.bulk_delim_var = tk.StringVar(value='|')
        ttk.Entry(delim_frame, textvariable=self.bulk_delim_var, width=8, 
                 style='Modern.TEntry').pack(side=tk.LEFT, padx=(10, 0))
        
        # Data input
        data_frame = ttk.LabelFrame(container, text="üìã D·ªØ li·ªáu (m·ªói d√≤ng m·ªôt b·∫£n ghi)", padding=15)
        data_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 15))
        
        self.bulk_text = tk.Text(data_frame, height=15, font=('Consolas', 10),
                               relief='solid', borderwidth=2, padx=10, pady=8)
        self.bulk_text.pack(fill=tk.BOTH, expand=True)
        
        # Buttons
        button_frame = ttk.Frame(container)
        button_frame.pack(fill=tk.X)
        
        ttk.Button(button_frame, text="üì• Nh·∫≠p h√†ng lo·∫°t", style='Primary.TButton',
                  command=self.bulk_add).pack(side=tk.LEFT, padx=(0, 10))
        ttk.Button(button_frame, text="üßπ X√≥a n·ªôi dung", style='Accent.TButton',
                  command=lambda: self.bulk_text.delete('1.0', tk.END)).pack(side=tk.LEFT, padx=(0, 10))
        ttk.Button(button_frame, text="‚ùå ƒê√≥ng", style='Danger.TButton',
                  command=self.bulk_modal.destroy).pack(side=tk.LEFT)

    def bulk_add(self):
        """Nh·∫≠p d·ªØ li·ªáu h√†ng lo·∫°t"""
        mapping = [v.get() for v in self.bulk_map_vars]
        if len(set(mapping)) != 4:
            messagebox.showerror("L·ªói", "√Ånh x·∫° 4 c·ªôt ph·∫£i l√† 4 tr∆∞·ªùng kh√°c nhau!")
            return
            
        delim = self.bulk_delim_var.get()
        if not delim:
            messagebox.showerror("L·ªói", "Vui l√≤ng nh·∫≠p d·∫•u ph√¢n c√°ch!")
            return
            
        text = self.bulk_text.get('1.0', tk.END).strip()
        if not text:
            messagebox.showerror("L·ªói", "Vui l√≤ng nh·∫≠p d·ªØ li·ªáu!")
            return
        
        # Create key index for duplicate checking
        key_to_index = {}
        for idx, it in enumerate(self.bm_data):
            if isinstance(it, dict):
                key_to_index[(it.get('TypeBM',''), it.get('ID',''), it.get('BmID',''))] = idx
            else:
                if len(it) >= 3:
                    key_to_index[(it[0], it[1], it[2])] = idx
        
        added = 0
        skipped_dup = 0
        skipped_invalid = 0
        
        for raw_line in text.splitlines():
            line = raw_line.strip()
            if not line:
                continue
                
            parts = line.split(delim)
            if len(parts) < 4:
                skipped_invalid += 1
                continue
                
            parts = [p.strip() for p in parts[:6]]  # Allow up to 6 columns
            record = {}
            
            try:
                for idx, field_name in enumerate(mapping):
                    record[field_name] = parts[idx]
                    
                # Ensure all required keys
                record = {
                    'TypeBM': record.get('TypeBM', ''),
                    'ID': record.get('ID', ''),
                    'BmID': record.get('BmID', ''),
                    'Link1': parts[3] if len(parts) > 3 else record.get('Link1',''),
                    'Link2': parts[4] if len(parts) > 4 else '',
                    'Link3': parts[5] if len(parts) > 5 else '',
                    'Note': ''
                }
            except Exception:
                skipped_invalid += 1
                continue
            
            # Check required fields
            if not record['TypeBM'] or not record['ID'] or not record['BmID'] or not record['Link1']:
                skipped_invalid += 1
                continue
            
            key = (record['TypeBM'], record['ID'], record['BmID'])
            if key in key_to_index:
                # Merge links into existing record
                i = key_to_index[key]
                if isinstance(self.bm_data[i], dict):
                    base = self.bm_data[i]
                else:
                    base = {
                        'TypeBM': self.bm_data[i][0], 
                        'ID': self.bm_data[i][1], 
                        'BmID': self.bm_data[i][2], 
                        'Link1': self.bm_data[i][3] if len(self.bm_data[i])>3 else '', 
                        'Link2': '', 
                        'Link3': '',
                        'Note': ''
                    }
                
                # Merge unique links
                for ln_key in ['Link1','Link2','Link3']:
                    new_link = record.get(ln_key, '')
                    if new_link and new_link not in [base.get('Link1',''), base.get('Link2',''), base.get('Link3','')]:
                        # Find empty slot
                        for slot in ['Link1','Link2','Link3']:
                            if not base.get(slot):
                                base[slot] = new_link
                                break
                                
                self.bm_data[i] = base
                skipped_dup += 1
            else:
                self.bm_data.append(record)
                key_to_index[key] = len(self.bm_data) - 1
                added += 1
        
        self.refresh_tree()
        self.save_json_db()
        self.update_folder_info()
        
        result_msg = f"‚úÖ Th√™m m·ªõi: {added}\n‚ö†Ô∏è Tr√πng: {skipped_dup}\n‚ùå L·ªói/thi·∫øu d·ªØ li·ªáu: {skipped_invalid}"
        messagebox.showinfo("K·∫øt qu·∫£ nh·∫≠p d·ªØ li·ªáu", result_msg)

    def refresh_tree(self, data=None):
        """L√†m m·ªõi Treeview theo d·ªØ li·ªáu hi·ªán c√≥."""
        # X√≥a c≈©
        for item in self.tree.get_children():
            self.tree.delete(item)
        # Reset mapping
        self.rowid_to_index = {}
        # ƒê·ªï d·ªØ li·ªáu
        data = data or self.bm_data
        for i, item in enumerate(data):
            if isinstance(item, dict):
                values = [
                    i + 1,
                    '‚¨ú',
                    item.get('TypeBM', ''),
                    item.get('ID', ''),
                    item.get('BmID', ''),
                    self.current_folder,
                    item.get('Note', ''),
                    item.get('Link1', ''),
                    item.get('Link2', ''),
                    item.get('Link3', ''),
                ]
            else:
                link1 = item[3] if len(item) > 3 else ''
                values = [
                    i + 1, '‚¨ú',
                    item[0] if len(item) > 0 else '',
                    item[1] if len(item) > 1 else '',
                    item[2] if len(item) > 2 else '',
                    self.current_folder,
                    '',
                    link1,
                    '',
                    ''
                ]
            tag = 'row_even' if (i % 2) == 0 else 'row_odd'
            row_id = self.tree.insert('', 'end', values=values, tags=(tag,))
            try:
                base_index = i if data is self.bm_data else self.bm_data.index(item)
            except Exception:
                base_index = i
            self.rowid_to_index[row_id] = base_index
        self.update_checkbox_display()
        self.update_status_bar()

    def update_checkbox_display(self):
        """ƒê·ªìng b·ªô c·ªôt 'Ch·ªçn' v·ªõi selection hi·ªán t·∫°i."""
        items = self.tree.get_children()
        selected = set(self.tree.selection())
        for it in items:
            vals = list(self.tree.item(it, 'values'))
            if len(vals) >= 2:
                vals[1] = '‚úÖ' if it in selected else '‚¨ú'
                self.tree.item(it, values=vals)
        self.update_status_bar()

    def update_status_bar(self):
        """C·∫≠p nh·∫≠t thanh tr·∫°ng th√°i T·ªïng | ƒê√£ ch·ªçn."""
        try:
            total = len(self.bm_data)
            selected = len(self.tree.selection())
            self.status_var.set(f"T·ªïng: {total} | ƒê√£ ch·ªçn: {selected}")
        except Exception:
            pass

    def on_select(self, event=None):
        """Khi selection thay ƒë·ªïi, c·∫≠p nh·∫≠t checkbox v√† status."""
        self.update_checkbox_display()
        self.update_status_bar()

    def on_tree_click(self, event):
        """X·ª≠ l√Ω click: toggle checkbox ·ªü c·ªôt 2, l∆∞u cell hi·ªán t·∫°i."""
        region = self.tree.identify_region(event.x, event.y)
        column = self.tree.identify_column(event.x)
        row_id = self.tree.identify_row(event.y)
        if region == 'cell' and column == '#2':
            # Toggle selection nh∆∞ checkbox
            if row_id:
                if row_id in self.tree.selection():
                    self.tree.selection_remove(row_id)
                else:
                    self.tree.selection_add(row_id)
                self.update_checkbox_display()
            return 'break'
        # L∆∞u cell ƒë·ªÉ copy/s·ª≠a
        self.current_cell = (row_id, column)
        return

    def on_cell_double_click(self, event):
        """Cho ph√©p s·ª≠a tr·ª±c ti·∫øp m·ªôt s·ªë c·ªôt."""
        row_id = self.tree.identify_row(event.y)
        column = self.tree.identify_column(event.x)
        if not row_id or not column:
            return
        col_index = int(column.replace('#', '')) - 1
        # Kh√¥ng cho s·ª≠a c√°c c·ªôt STT(0), Ch·ªçn(1), Th∆∞ m·ª•c(5)
        if col_index in (0, 1, 5):
            return
        bbox = self.tree.bbox(row_id, column)
        if not bbox:
            return
        x, y, w, h = bbox
        old_values = list(self.tree.item(row_id, 'values'))
        old_text = old_values[col_index]
        editor = ttk.Entry(self.tree)
        editor.insert(0, old_text)
        editor.select_range(0, tk.END)
        editor.focus_set()
        editor.place(x=x, y=y, width=w, height=h)

        def finish_edit(save):
            new_text = editor.get()
            editor.destroy()
            if not save or new_text == old_text:
                return
            # C·∫≠p nh·∫≠t tree
            old_values[col_index] = new_text
            self.tree.item(row_id, values=old_values)
            # √Ånh x·∫° v·ªÅ d·ªØ li·ªáu
            data_index = self.rowid_to_index.get(row_id, -1)
            if 0 <= data_index < len(self.bm_data):
                # ƒê·∫£m b·∫£o record l√† dict chu·∫©n
                rec = self.bm_data[data_index]
                if not isinstance(rec, dict):
                    rec = {
                        'TypeBM': rec[0] if len(rec) > 0 else '',
                        'ID': rec[1] if len(rec) > 1 else '',
                        'BmID': rec[2] if len(rec) > 2 else '',
                        'Link1': rec[3] if len(rec) > 3 else '',
                        'Link2': '',
                        'Link3': '',
                        'Note': ''
                    }
                key_map = {2: 'TypeBM', 3: 'ID', 4: 'BmID', 6: 'Note', 7: 'Link1', 8: 'Link2', 9: 'Link3'}
                field = key_map.get(col_index)
                if field:
                    rec[field] = new_text
                    self.bm_data[data_index] = rec
                    self.save_json_db()
                    self.update_folder_info()
                    self.update_status_bar()

        editor.bind('<Return>', lambda e: finish_edit(True))
        editor.bind('<Escape>', lambda e: finish_edit(False))
        editor.bind('<FocusOut>', lambda e: finish_edit(True))

    def copy_cell(self, event=None):
        """Copy n·ªôi dung √¥ hi·ªán t·∫°i (Ctrl+C)."""
        row_id, column = self.current_cell
        if not row_id or not column:
            return
        col_index = int(column.replace('#', '')) - 1
        values = self.tree.item(row_id, 'values')
        if not values or col_index < 0 or col_index >= len(values):
            return
        text = str(values[col_index])
        try:
            self.root.clipboard_clear()
            self.root.clipboard_append(text)
            self.root.update()
        except Exception:
            pass

    def sort_by_column(self, column_id):
        """S·∫Øp x·∫øp tƒÉng/gi·∫£m theo m·ªôt c·ªôt; gi·ªØ l·∫°i STT m·ªõi."""
        items = self.tree.get_children('')
        if not items:
            return
        try:
            col_index = self.columns.index(column_id)
        except ValueError:
            return
        if column_id == 'Ch·ªçn':
            return
        rows = []
        for it in items:
            vals = self.tree.item(it, 'values')
            key = str(vals[col_index]) if col_index < len(vals) else ''
            rows.append((key.lower(), it))
        ascending = not self.sort_directions.get(column_id, True)
        self.sort_directions[column_id] = ascending
        rows.sort(key=lambda r: r[0])
        if not ascending:
            rows.reverse()
        for idx, (_, it) in enumerate(rows):
            self.tree.move(it, '', idx)
        for idx, it in enumerate(self.tree.get_children('')):
            vals = list(self.tree.item(it, 'values'))
            if len(vals) > 0:
                vals[0] = idx + 1
                self.tree.item(it, values=vals)
        self.update_checkbox_display()
        self.update_status_bar()

    def export_csv(self):
        """Export CSV v·ªõi c√°c c·ªôt Link1-3."""
        filename = filedialog.asksaveasfilename(
            defaultextension=".csv",
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")]
        )
        if filename:
            try:
                with open(filename, 'w', newline='', encoding='utf-8') as file:
                    writer = csv.writer(file)
                    writer.writerow(['TypeBM', 'ID', 'BmID', 'Link1', 'Link2', 'Link3', 'Note'])
                    for item in self.bm_data:
                        if isinstance(item, dict):
                            writer.writerow([
                                item.get('TypeBM', ''), item.get('ID', ''), item.get('BmID', ''),
                                item.get('Link1', ''), item.get('Link2', ''), item.get('Link3', ''),
                                item.get('Note', '')
                            ])
                        else:
                            writer.writerow([
                                item[0] if len(item) > 0 else '',
                                item[1] if len(item) > 1 else '',
                                item[2] if len(item) > 2 else '',
                                item[3] if len(item) > 3 else '',
                                '', '', ''
                            ])
                messagebox.showinfo("Th√†nh c√¥ng", f"‚úÖ ƒê√£ export file: {filename}")
            except Exception as e:
                messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ export file: {str(e)}")

    def import_csv(self):
        """Import CSV, h·ªó tr·ª£ Link1-3 v√† Link c≈©."""
        filename = filedialog.askopenfilename(
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")]
        )
        if filename:
            try:
                with open(filename, 'r', encoding='utf-8') as file:
                    reader = csv.DictReader(file)
                    rows = list(reader)
                imported = []
                for r in rows:
                    # H·ªó tr·ª£ header c≈© 'Link'
                    link1 = r.get('Link1') or r.get('Link') or ''
                    rec = {
                        'TypeBM': r.get('TypeBM', ''),
                        'ID': r.get('ID', ''),
                        'BmID': r.get('BmID', ''),
                        'Link1': link1,
                        'Link2': r.get('Link2', ''),
                        'Link3': r.get('Link3', ''),
                        'Note': r.get('Note', ''),
                    }
                    if any([rec['TypeBM'], rec['ID'], rec['BmID'], rec['Link1'], rec['Link2'], rec['Link3']]):
                        imported.append(rec)
                if not imported:
                    messagebox.showwarning("C·∫£nh b√°o", "File CSV kh√¥ng c√≥ d·ªØ li·ªáu h·ª£p l·ªá!")
                    return
                if messagebox.askyesno("X√°c nh·∫≠n", "Th√™m v√†o d·ªØ li·ªáu hi·ªán t·∫°i?"):
                    self.bm_data.extend(imported)
                else:
                    self.bm_data = imported
                self.refresh_tree()
                self.save_json_db()
                messagebox.showinfo("Th√†nh c√¥ng", f"‚úÖ ƒê√£ import file: {filename}")
            except Exception as e:
                messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ import file: {str(e)}")

    def show_stats(self):
        """(ƒê√£ b·ªè theo y√™u c·∫ßu)"""
        messagebox.showinfo("Th√¥ng tin", "Ch·ª©c nƒÉng Th·ªëng k√™ ƒë√£ ƒë∆∞·ª£c ·∫©n.")


def main():
    root = tk.Tk()
    app = BMManager(root)
    root.mainloop()


if __name__ == "__main__":
    main()